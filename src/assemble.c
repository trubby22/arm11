#include <stdio.h>
#include <stdint.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "assemble.h"
#include "global_vars_2.c"
#include "swap.c"
#include "text_handling.c"
#include "opcodes.c"
#include "rotate_left.c"
#include "data_processing_2.c"
#include "multiply_2.c"
#include "sdt_helpers.c"
#include "single_data_transfer_2.c"
#include "branch_2.c"
#include "special.c"
#include "allocate.c"

int main(int argc, char** argv) {
	label = alloc_label();
	mnemonic = alloc_mnemonic();
	operands = alloc_operands();
	line = alloc_line();
	num_operands = 0;
	char labels[MAX_LABELS_COUNT][MAX_LINE_SIZE];
	uint8_t memory_addresses[MAX_LABELS_COUNT];
	bool label_present = false;	
	int i = 0;
	curr_line = 0;
	
	assert(argc == 3 && "Enter two arguments");

	FILE* fptr = fopen(argv[1], "r"); // "r" - read
	assert(fptr != NULL && "Could not open file");

	FILE* fptr_2 = fopen(argv[2], "wb"); // "wb" - write binary
	assert(fptr_2 != NULL && "Could not open file");

	// first pass
	while (fgets(line, MAX_LINE_SIZE, fptr)) {
		// check if end of file reached
		if (*line == '\n') {
			break;
		}
		remove_newline(line);
		label_present = tokenizer(line, label, mnemonic, operands, &num_operands);
		if (label_present) {
			strcpy(labels[i], label);
			memory_addresses[i] = curr_line;
			i++;
		} else {
			curr_line++;
		}	
	}

	uint32_t instruction;
	num_lines = curr_line;
	consts_size = 0;
	curr_line = 0;
	int target_address;
	
	fseek(fptr, 0, SEEK_SET);

	// second pass		
	while (fgets(line, MAX_LINE_SIZE, fptr)) {
		// check if end of file reached
		if (*line == '\n') {
			break;
		}
		remove_newline(line);
		label_present = tokenizer(line, label, mnemonic, operands, &num_operands);
		if (!label_present) {
			// choose what function to call
			switch (string_to_opcode(mnemonic) / 10) {
				case 1:
					instruction = data_processing();
					break;
				case 2:
					instruction = multiply();
					break;
				case 3:
					instruction = single_data_transfer();
					break;
				case 4:
					// find out the address of the label that branch instruction is referring to
					for (int j = 0; j < i; j++) {
						if (strcmp(labels[j], operands[0]) == 0) {
							target_address = memory_addresses[j] * 4;
						}
					}
					instruction = branch(target_address);
					break;
				case 5:
					instruction = special();
					break;
				default:
					printf("Mnemonic not recognised\n");
					break;
			}
			curr_line++;
			// store instruction in output file
			fwrite(&instruction, sizeof(instruction), 1, fptr_2);
		}
	}
	
	// store constants generated by SDT in the output file
	for (int j = 0; j < consts_size; j++) {
		fwrite(&(constants[j]), sizeof(uint32_t), 1, fptr_2);
	}

	free(label);
	free(mnemonic);
	free(operands);
	fclose(fptr_2);
	fclose(fptr);
	return EXIT_SUCCESS;
}

